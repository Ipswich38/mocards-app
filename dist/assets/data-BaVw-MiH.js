import{s as o}from"./supabase-BYaNx0mI.js";const m={starter:{limit:500,price:299},growth:{limit:1e3,price:499},pro:{limit:2e3,price:799},enterprise:{limit:3e3,price:999}},S={starter:m.starter.limit,growth:m.growth.limit,pro:m.pro.limit,enterprise:m.enterprise.limit},w={starter:m.starter.price,growth:m.growth.price,pro:m.pro.price,enterprise:m.enterprise.price};class E{syncStatus="synced";lastSync=null;subscriptions=[];constructor(){this.setupRealTimeSubscriptions(),this.checkConnection()}async checkConnection(){try{const{error:e}=await o.from("cards").select("id").limit(1);if(e)throw e;return this.setSyncStatus("synced"),!0}catch(e){return console.error("[SupabaseCloudSync] Connection failed:",e),this.setSyncStatus("offline"),!1}}setSyncStatus(e){this.syncStatus=e,e==="synced"&&(this.lastSync=new Date)}setupRealTimeSubscriptions(){const e=o.channel("cards-changes").on("postgres_changes",{event:"*",schema:"public",table:"cards"},s=>{console.log("[SupabaseCloudSync] Cards changed:",s),this.lastSync=new Date}).subscribe(),t=o.channel("clinics-changes").on("postgres_changes",{event:"*",schema:"public",table:"clinics"},s=>{console.log("[SupabaseCloudSync] Clinics changed:",s),this.lastSync=new Date}).subscribe(),a=o.channel("appointments-changes").on("postgres_changes",{event:"*",schema:"public",table:"appointments"},s=>{console.log("[SupabaseCloudSync] Appointments changed:",s),this.lastSync=new Date}).subscribe(),n=o.channel("perks-changes").on("postgres_changes",{event:"*",schema:"public",table:"perks"},s=>{console.log("[SupabaseCloudSync] Perks changed:",s),this.lastSync=new Date}).subscribe(),l=o.channel("redemptions-changes").on("postgres_changes",{event:"*",schema:"public",table:"perk_redemptions"},s=>{console.log("[SupabaseCloudSync] Perk redemptions changed:",s),this.lastSync=new Date}).subscribe();this.subscriptions=[e,t,a,n,l]}async getAllCards(){try{this.setSyncStatus("syncing");let e=[],t=!0,a=0;const n=1e3;for(;t;){const{data:s,error:i}=await o.from("cards").select("*").order("created_at",{ascending:!1}).range(a,a+n-1);if(i)throw i;s&&s.length>0?(e=e.concat(s),a+=n,t=s.length===n):t=!1}console.log(`[SupabaseCloudSync] Retrieved ${e.length} total cards from database`),e||(e=[]);const l=(e||[]).map(s=>({id:s.id,controlNumber:s.control_number||`MOC-${s.id}`,fullName:s.full_name||"",status:s.status==="active"||s.status==="activated"?"active":"inactive",perksTotal:s.perks_total||5,perksUsed:s.perks_used||0,clinicId:s.clinic_id||"",expiryDate:s.expiry_date||"2025-12-31",notes:s.notes||"",createdAt:s.created_at,updatedAt:s.updated_at||s.created_at}));return this.setSyncStatus("synced"),l}catch(e){return console.error("[SupabaseCloudSync] Error getting cards:",e),this.setSyncStatus("error"),[]}}async createCard(e){try{this.setSyncStatus("syncing");const t={control_number:e.controlNumber,full_name:e.fullName||"",status:e.status,perks_total:e.perksTotal||5,perks_used:e.perksUsed||0,expiry_date:e.expiryDate};e.clinicId&&e.clinicId.trim()!==""&&(t.clinic_id=e.clinicId),e.notes&&(t.notes=e.notes);const{data:a,error:n}=await o.from("cards").insert(t).select().single();if(n)throw n;const l={id:a.id,controlNumber:a.control_number,fullName:a.full_name||"",status:a.status,perksTotal:a.perks_total,perksUsed:a.perks_used,clinicId:a.clinic_id||"",expiryDate:a.expiry_date,notes:a.notes||"",createdAt:a.created_at,updatedAt:a.updated_at||a.created_at};return this.setSyncStatus("synced"),l}catch(t){throw console.error("[SupabaseCloudSync] Error creating card:",t),this.setSyncStatus("error"),t}}async updateCard(e,t){try{this.setSyncStatus("syncing");const a={};t.status!==void 0&&(a.status=t.status==="active"?"activated":"unactivated"),t.clinicId!==void 0&&(a.clinic_id=t.clinicId||null),t.fullName!==void 0&&(a.full_name=t.fullName),t.perksTotal!==void 0&&(a.perks_total=t.perksTotal),t.perksUsed!==void 0&&(a.perks_used=t.perksUsed),t.notes!==void 0&&(a.notes=t.notes),t.expiryDate!==void 0&&(a.expiry_date=t.expiryDate),a.updated_at=new Date().toISOString();const{error:n}=await o.from("cards").update(a).eq("id",e);if(n)throw n;return this.setSyncStatus("synced"),!0}catch(a){return console.error("[SupabaseCloudSync] Error updating card:",a),this.setSyncStatus("error"),!1}}async getAllClinics(){try{this.setSyncStatus("syncing");const{data:e,error:t}=await o.from("clinics").select("*").order("created_at",{ascending:!1});if(t)throw t;const a=(e||[]).map(n=>({id:n.id,name:n.clinic_name,username:n.username||n.clinic_code.toLowerCase(),code:n.clinic_code,password:n.password_hash||"clinic123",plan:"starter",maxCards:500,region:n.region||"NCR",address:n.address,email:n.contact_email,contactNumber:n.contact_phone,subscriptionStatus:n.status==="active"?"active":"suspended",subscriptionStartDate:n.created_at.split("T")[0],subscriptionPrice:w.starter,createdAt:n.created_at,updatedAt:n.updated_at,isActive:n.status==="active"}));return this.setSyncStatus("synced"),a}catch(e){return console.error("[SupabaseCloudSync] Error getting clinics:",e),this.setSyncStatus("error"),[]}}async createClinic(e){try{this.setSyncStatus("syncing");const t={clinic_name:e.name,username:e.username,clinic_code:e.code,password_hash:e.password,region:e.region,address:e.address,contact_email:e.email,contact_phone:e.contactNumber,status:e.isActive!==!1?"active":"inactive"},{data:a,error:n}=await o.from("clinics").insert(t).select().single();if(n)throw n;const l={id:a.id,name:a.clinic_name,username:e.username,code:a.clinic_code,password:e.password,plan:e.plan,maxCards:e.maxCards,region:a.region,address:a.address,email:a.contact_email,contactNumber:a.contact_phone,subscriptionStatus:a.status==="active"?"active":"suspended",subscriptionStartDate:a.created_at.split("T")[0],subscriptionPrice:w[e.plan],createdAt:a.created_at,updatedAt:a.updated_at,isActive:a.status==="active"};return this.setSyncStatus("synced"),l}catch(t){throw console.error("[SupabaseCloudSync] Error creating clinic:",t),this.setSyncStatus("error"),t}}async getAllAppointments(){try{this.setSyncStatus("syncing");const{data:e,error:t}=await o.from("appointments").select("*").order("created_at",{ascending:!1});if(t)throw t;const a=(e||[]).map(n=>({id:n.id,cardControlNumber:n.control_number,clinicId:n.assigned_clinic_id||"",patientName:n.patient_name||"Unknown Patient",patientEmail:n.patient_email||"patient@example.com",patientPhone:n.patient_phone||"+63 000 000 0000",preferredDate:n.appointment_date,preferredTime:n.appointment_time,serviceType:n.service_type||"General Consultation",perkRequested:n.perk_type,status:this.mapAppointmentStatus(n.status),notes:n.cardholder_notes,createdAt:n.created_at}));return this.setSyncStatus("synced"),a}catch(e){return console.error("[SupabaseCloudSync] Error getting appointments:",e),this.setSyncStatus("error"),[]}}async createAppointment(e){try{this.setSyncStatus("syncing");const t={control_number:e.cardControlNumber,assigned_clinic_id:e.clinicId,appointment_date:e.preferredDate,appointment_time:e.preferredTime,perk_type:e.perkRequested||e.serviceType,cardholder_notes:e.notes,status:"waiting_for_approval",patient_name:e.patientName,patient_email:e.patientEmail,patient_phone:e.patientPhone,service_type:e.serviceType},{data:a,error:n}=await o.from("appointments").insert(t).select().single();if(n)throw n;const l={id:a.id,cardControlNumber:a.control_number,clinicId:a.assigned_clinic_id,patientName:a.patient_name,patientEmail:a.patient_email,patientPhone:a.patient_phone,preferredDate:a.appointment_date,preferredTime:a.appointment_time,serviceType:a.service_type,perkRequested:a.perk_type,status:this.mapAppointmentStatus(a.status),notes:a.cardholder_notes,createdAt:a.created_at};return this.setSyncStatus("synced"),l}catch(t){throw console.error("[SupabaseCloudSync] Error creating appointment:",t),this.setSyncStatus("error"),t}}async updateAppointment(e,t){try{this.setSyncStatus("syncing");const a={};t.status!==void 0&&(a.status=this.mapAppointmentStatusToSupabase(t.status)),t.notes!==void 0&&(a.cardholder_notes=t.notes),a.updated_at=new Date().toISOString();const{error:n}=await o.from("appointments").update(a).eq("id",e);if(n)throw n;return this.setSyncStatus("synced"),!0}catch(a){return console.error("[SupabaseCloudSync] Error updating appointment:",a),this.setSyncStatus("error"),!1}}async getAllPerks(){try{this.setSyncStatus("syncing");const{data:e,error:t}=await o.from("perk_templates").select("*").eq("is_active",!0).order("created_at",{ascending:!1});if(t)throw t;const a=(e||[]).map(n=>({id:n.id,type:this.mapPerkType(n.type),name:n.name,description:n.description||"",value:n.value||0,isActive:n.is_active,validFor:365,requiresApproval:!1,createdAt:n.created_at,updatedAt:n.updated_at}));return this.setSyncStatus("synced"),a}catch(e){return console.error("[SupabaseCloudSync] Error getting perks:",e),this.setSyncStatus("error"),[]}}async getAllPerkRedemptions(){try{this.setSyncStatus("syncing");const{data:e,error:t}=await o.from("perk_redemptions").select("*").order("used_at",{ascending:!1});if(t)throw console.error("[SupabaseCloudSync] Perk redemptions query failed:",t),t;const a=(e||[]).map(n=>({id:n.id,cardControlNumber:n.card_control_number||"Unknown",perkId:n.perk_id,perkName:n.perk_name||"Unknown Perk",clinicId:n.clinic_id,claimantName:n.claimant_name||"Unknown Patient",handledBy:n.handled_by||"System",serviceType:n.service_type||"General Service",usedAt:n.used_at,value:n.value||0,notes:n.notes||""}));return this.setSyncStatus("synced"),a}catch(e){return console.error("[SupabaseCloudSync] Error getting perk redemptions:",e),this.setSyncStatus("error"),[]}}mapAppointmentStatus(e){return{waiting_for_approval:"pending",approved:"accepted",pending_reschedule:"rescheduled",approved_reschedule:"accepted",cancelled:"cancelled",completed:"completed"}[e]||"pending"}mapAppointmentStatusToSupabase(e){return{pending:"waiting_for_approval",accepted:"approved",declined:"cancelled",rescheduled:"pending_reschedule",completed:"completed",cancelled:"cancelled"}[e]||"waiting_for_approval"}mapPerkType(e){return{consultation:"consultation",cleaning:"dental_cleaning",xray:"xray",discount:"discount",service:"treatment"}[e]||"consultation"}getSyncStatus(){return this.syncStatus}getLastSync(){return this.lastSync}async forceSync(){return await this.checkConnection()}cleanup(){this.subscriptions.forEach(e=>{o.removeChannel(e)}),this.subscriptions=[]}}const u=new E,c={cards:{getAll:()=>u.getAllCards(),save:async r=>(console.warn("[CloudOperations] Batch save not implemented for Supabase"),!0),add:async r=>{try{return await u.createCard(r)}catch(e){throw console.error("[CloudOperations] Error adding card:",e),e}},update:async(r,e)=>await u.updateCard(r,e),remove:async r=>{try{const{error:e}=await o.from("cards").delete().eq("id",r);return!e}catch(e){return console.error("[CloudOperations] Error removing card:",e),!1}}},clinics:{getAll:()=>u.getAllClinics(),save:async r=>(console.warn("[CloudOperations] Batch save not implemented for Supabase"),!0),add:async r=>{try{return await u.createClinic(r),!0}catch(e){return console.error("[CloudOperations] Error adding clinic:",e),!1}},update:async(r,e)=>{try{const{error:t}=await o.from("clinics").update({clinic_name:e.name,contact_email:e.email,contact_phone:e.contactNumber,updated_at:new Date().toISOString()}).eq("id",r);return!t}catch(t){return console.error("[CloudOperations] Error updating clinic:",t),!1}},remove:async r=>{try{const{error:e}=await o.from("clinics").delete().eq("id",r);return!e}catch(e){return console.error("[CloudOperations] Error removing clinic:",e),!1}}},appointments:{getAll:()=>u.getAllAppointments(),save:async r=>(console.warn("[CloudOperations] Batch save not implemented for Supabase"),!0),add:async r=>{try{return await u.createAppointment(r),!0}catch(e){return console.error("[CloudOperations] Error adding appointment:",e),!1}},update:async(r,e)=>await u.updateAppointment(r,e),remove:async r=>{try{const{error:e}=await o.from("appointments").delete().eq("id",r);return!e}catch(e){return console.error("[CloudOperations] Error removing appointment:",e),!1}}},perks:{getAll:()=>u.getAllPerks(),save:async r=>(console.warn("[CloudOperations] Batch save not implemented for Supabase"),!0),add:async r=>{try{const{error:e}=await o.from("perks").insert({name:r.name,description:r.description,type:r.type,value:r.value,is_active:r.isActive,is_system_default:!1});return!e}catch(e){return console.error("[CloudOperations] Error adding perk:",e),!1}},update:async(r,e)=>{try{const{error:t}=await o.from("perks").update({name:e.name,description:e.description,default_value:e.value,is_active:e.isActive,updated_at:new Date().toISOString()}).eq("id",r);return!t}catch(t){return console.error("[CloudOperations] Error updating perk:",t),!1}},remove:async r=>{try{const{error:e}=await o.from("perk_templates").delete().eq("id",r);return!e}catch(e){return console.error("[CloudOperations] Error removing perk:",e),!1}}},perkRedemptions:{getAll:()=>u.getAllPerkRedemptions(),save:async r=>(console.warn("[CloudOperations] Batch save not implemented for Supabase"),!0),add:async r=>{try{const{data:e,error:t}=await o.from("perk_redemptions").insert({perk_id:r.perkId,perk_name:r.perkName,clinic_id:r.clinicId,card_control_number:r.cardControlNumber,claimant_name:r.claimantName,handled_by:r.handledBy,service_type:r.serviceType,used_at:r.usedAt,value:r.value,notes:r.notes||null}).select().single();if(t)throw t;return{id:e.id,cardControlNumber:e.card_control_number,perkId:e.perk_id,perkName:e.perk_name,clinicId:e.clinic_id,claimantName:e.claimant_name,handledBy:e.handled_by,serviceType:e.service_type,usedAt:e.used_at,value:e.value,notes:e.notes||""}}catch(e){throw console.error("[CloudOperations] Error adding perk redemption:",e),e}}},sync:{getStatus:()=>u.getSyncStatus(),getLastSync:()=>u.getLastSync(),forceSync:()=>u.forceSync()}},k=(r,e,t)=>`MOC-${r.toString().padStart(5,"0")}-${e}-${t}`,O={getAll:async()=>await c.cards.getAll(),getByControlNumber:async r=>(await c.cards.getAll()).find(t=>t.controlNumber===r)||null,getByClinicId:async r=>(await c.cards.getAll()).filter(t=>t.clinicId===r),create:async r=>{try{return await c.cards.add(r)}catch(e){throw console.error("Failed to create card:",e),e}},generateCards:async(r,e,t,a=5)=>{const n=[];if(console.log("[GENERATOR] Creating",r,"cards with region:",e,"areaCode:",t),!e||!t)throw console.error("[GENERATOR] Invalid input - region and areaCode are required"),console.error("[GENERATOR] Received:",{region:e,areaCode:t,quantity:r,perksTotal:a}),new Error("Region and Area Code are required for card generation");if(r<=0)throw console.error("[GENERATOR] Invalid quantity:",r),new Error("Quantity must be greater than 0");console.log("[GENERATOR] Input validation passed"),console.log("[GENERATOR] Fetching existing cards...");const l=await c.cards.getAll();console.log("[GENERATOR] Found",l.length,"existing cards");const s=new Set(l.map(p=>p.controlNumber));let i=1;console.log("[GENERATOR] Finding highest existing ID across all cards...");const g=l.filter(p=>p.controlNumber.startsWith("MOC-"));if(console.log("[GENERATOR] Found",g.length,"existing MOC cards"),g.length>0){const p=Math.max(...g.map(f=>{const h=f.controlNumber.match(/MOC-(\d+)/);return h?parseInt(h[1]):0}));i=p+1,console.log("[GENERATOR] Highest existing ID found:",p,"- Starting from:",i)}else console.log("[GENERATOR] No existing MOC cards found, starting from ID 1");console.log("[GENERATOR] Starting from ID:",i);let d=0,A=0,y=0;const v=r*5,_=Math.min(10,Math.max(5,r/10)),b=50;for(console.log("[GENERATOR] Configuration:",{maxAttempts:v,maxConsecutiveFailures:_,batchSize:b,targetQuantity:r}),console.log("[GENERATOR] Processing in batches for optimal performance...");d<r&&A<v&&y<_;){const p=k(i,e,t);if(A++,s.has(p)){console.log("[GENERATOR] Skipping existing card:",p),i++;continue}const f={controlNumber:p,fullName:"",status:"inactive",perksTotal:a,perksUsed:0,clinicId:"",expiryDate:"2025-12-31"};try{const h=await c.cards.add(f);n.push(h),s.add(p),d++,i++,y=0,(d%10===0||d===1||d===r)&&console.log(`[GENERATOR] Progress: ${d}/${r} cards created (${Math.round(d/r*100)}%)`),d%b===0&&d<r&&(console.log(`[GENERATOR] Batch of ${b} completed, brief pause...`),await new Promise(C=>setTimeout(C,100)))}catch(h){if(console.error("[GENERATOR] Failed to create card:",f.controlNumber,h),y++,i++,y>=_){console.error(`[GENERATOR] Too many consecutive failures (${y}), stopping generation.`);break}else console.log(`[GENERATOR] Continuing after failure (${y}/${_})...`)}}return d<r&&console.warn(`[GENERATOR] Only created ${d} out of ${r} requested cards`),console.log("[GENERATOR] Successfully created",d,"unique cards"),n},updateStatus:async(r,e)=>{const a=(await c.cards.getAll()).find(n=>n.controlNumber===r);return a?(await c.cards.update(a.id,{status:e}),!0):!1},assignToClinic:async(r,e)=>{const t=await c.clinics.getAll(),a=await c.cards.getAll(),n=t.find(i=>i.id===e);if(!n)return!1;const l=a.filter(i=>i.clinicId===e).length,s=S[n.plan];return l+r.length>s?!1:(await Promise.all(r.map(async i=>{const g=a.find(d=>d.controlNumber===i);g&&await c.cards.update(g.id,{clinicId:e})})),!0)},updatePerks:async(r,e)=>{const a=(await c.cards.getAll()).find(n=>n.controlNumber===r);if(a){const n=Math.min(e,a.perksTotal);return await c.cards.update(a.id,{perksUsed:n}),!0}return!1},delete:async r=>{const t=(await c.cards.getAll()).find(a=>a.controlNumber===r);return t?(await c.cards.remove(t.id),!0):!1}},R={getAll:async()=>{try{return await c.clinics.getAll()}catch(r){console.warn("Cloud sync failed, using Supabase fallback:",r);const{data:e}=await o.from("clinics").select("*");return(e||[]).map(t=>({id:t.id,name:t.clinic_name,username:t.clinic_code.toLowerCase(),region:"4A",plan:"starter",code:t.clinic_code,password:t.password_hash,subscriptionPrice:w.starter,subscriptionStatus:"active",subscriptionStartDate:new Date().toISOString(),maxCards:S.starter,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),isActive:!0}))}},getById:async r=>(await c.clinics.getAll()).find(t=>t.id===r)||null,getByCode:async r=>(await c.clinics.getAll()).find(t=>t.code===r)||null,authenticate:async(r,e)=>{try{const{data:t}=await o.from("clinics").select("*").eq("clinic_code",r).single();if(t&&t.password_hash===e)return{id:t.id,name:t.clinic_name,username:t.clinic_code.toLowerCase(),region:"4A",plan:"starter",code:t.clinic_code,password:t.password_hash,subscriptionPrice:w.starter,subscriptionStatus:"active",subscriptionStartDate:new Date().toISOString(),maxCards:S.starter,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),isActive:!0}}catch(t){console.error("Authentication error:",t)}return null},create:async r=>{const e={...r,id:`clinic_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,subscriptionStatus:"active",subscriptionStartDate:new Date().toISOString(),maxCards:S[r.plan],createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),isActive:!0};return await c.clinics.add(e),e},update:async(r,e)=>(await c.clinics.getAll()).find(n=>n.id===r)?(await c.clinics.update(r,e),!0):!1,delete:async r=>(await c.clinics.remove(r),!0),getAssignedCardsCount:async r=>(await c.cards.getAll()).filter(t=>t.clinicId===r).length,getPlanLimit:async r=>{const t=(await c.clinics.getAll()).find(a=>a.id===r);return t?S[t.plan]:0}},I={getAll:async()=>await c.appointments.getAll(),getByClinicId:async r=>(await c.appointments.getAll()).filter(t=>t.clinicId===r),create:async r=>{const e={...r,id:`appointment_${Date.now()}_${Math.random().toString(36).substr(2,9)}`};return await c.appointments.add(e),e},updateStatus:async(r,e)=>(await c.appointments.getAll()).find(n=>n.id===r)?(await c.appointments.update(r,{status:e}),!0):!1};export{I as a,R as b,O as c};
