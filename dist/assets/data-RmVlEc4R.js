import{r as y}from"./charts-sad3owxz.js";import{u as k,t as C,a as N,d as n,P as h,s as E,e as O,D as b}from"./index-Dv95vNL-.js";const G=(e={})=>{const{enabled:t=!0,checkInterval:r=3e4,showNotifications:a=!0}=e,{addToast:s}=k(),d=y.useRef(null),m=y.useRef(!1),i=async()=>{try{{const l=await(await fetch("/index.html",{cache:"no-cache",headers:{"Cache-Control":"no-cache"}})).text(),w=l.match(/<script[^>]*src="[^"]*assets[^"]*\.js"[^>]*>/),g=l.match(/<meta name="version" content="([^"]*)">/);return g?g[1]:w?w[0]:null}}catch(o){return console.warn("Failed to check for app updates:",o),null}},u=async()=>{if(!(m.current||!t)){m.current=!0;try{const o=await i();if(o&&d.current){if(o!==d.current){a&&s(C("App Updated","A new version is available. The page will refresh automatically.")),setTimeout(()=>{window.location.reload()},2e3);return}}else o&&!d.current&&(d.current=o)}catch(o){console.warn("Update check failed:",o)}finally{m.current=!1}}};return y.useEffect(()=>{if(!t)return;i().then(g=>{d.current=g});const o=setInterval(u,r),l=()=>{document.hidden||setTimeout(u,1e3)};document.addEventListener("visibilitychange",l);const w=()=>{setTimeout(u,1e3)};return window.addEventListener("online",w),()=>{clearInterval(o),document.removeEventListener("visibilitychange",l),window.removeEventListener("online",w)}},[t,r,a]),{forceRefresh:()=>{a&&s(N("Refreshing","Updating to the latest version...")),setTimeout(()=>{window.location.reload()},500)},checkForUpdates:u}},I=(e,t,r)=>`MOC-${e.toString().padStart(5,"0")}-${t}-${r}`,x={getAll:async()=>await n.cards.getAll(),getByControlNumber:async e=>(await n.cards.getAll()).find(r=>r.controlNumber===e)||null,getByClinicId:async e=>(await n.cards.getAll()).filter(r=>r.clinicId===e),create:async e=>{try{return await n.cards.add(e)}catch(t){throw console.error("Failed to create card:",t),t}},generateCards:async(e,t,r,a=5)=>{const s=[];if(console.log("[GENERATOR] Creating",e,"cards with region:",t,"areaCode:",r),!t||!r)throw console.error("[GENERATOR] Invalid input - region and areaCode are required"),console.error("[GENERATOR] Received:",{region:t,areaCode:r,quantity:e,perksTotal:a}),new Error("Region and Area Code are required for card generation");if(e<=0)throw console.error("[GENERATOR] Invalid quantity:",e),new Error("Quantity must be greater than 0");console.log("[GENERATOR] Input validation passed"),console.log("[GENERATOR] Fetching existing cards...");const d=await n.cards.getAll();console.log("[GENERATOR] Found",d.length,"existing cards");const m=new Set(d.map(p=>p.controlNumber));let i=1;console.log("[GENERATOR] Finding highest existing ID across all cards...");const u=d.filter(p=>p.controlNumber.startsWith("MOC-"));if(console.log("[GENERATOR] Found",u.length,"existing MOC cards"),u.length>0){const p=Math.max(...u.map(A=>{const f=A.controlNumber.match(/MOC-(\d+)/);return f?parseInt(f[1]):0}));i=p+1,console.log("[GENERATOR] Highest existing ID found:",p,"- Starting from:",i)}else console.log("[GENERATOR] No existing MOC cards found, starting from ID 1");console.log("[GENERATOR] Starting from ID:",i);let c=0,o=0,l=0;const w=e*5,g=Math.min(10,Math.max(5,e/10)),R=50;for(console.log("[GENERATOR] Configuration:",{maxAttempts:w,maxConsecutiveFailures:g,batchSize:R,targetQuantity:e}),console.log("[GENERATOR] Processing in batches for optimal performance...");c<e&&o<w&&l<g;){const p=I(i,t,r);if(o++,m.has(p)){console.log("[GENERATOR] Skipping existing card:",p),i++;continue}const A={controlNumber:p,fullName:"",status:"inactive",perksTotal:a,perksUsed:0,clinicId:"",expiryDate:"2025-12-31"};try{const f=await n.cards.add(A);s.push(f),m.add(p),c++,i++,l=0,(c%10===0||c===1||c===e)&&console.log(`[GENERATOR] Progress: ${c}/${e} cards created (${Math.round(c/e*100)}%)`),c%R===0&&c<e&&(console.log(`[GENERATOR] Batch of ${R} completed, brief pause...`),await new Promise(S=>setTimeout(S,100)))}catch(f){if(console.error("[GENERATOR] Failed to create card:",A.controlNumber,f),l++,i++,l>=g){console.error(`[GENERATOR] Too many consecutive failures (${l}), stopping generation.`);break}else console.log(`[GENERATOR] Continuing after failure (${l}/${g})...`)}}return c<e&&console.warn(`[GENERATOR] Only created ${c} out of ${e} requested cards`),console.log("[GENERATOR] Successfully created",c,"unique cards"),s},updateStatus:async(e,t)=>{const a=(await n.cards.getAll()).find(s=>s.controlNumber===e);return a?(await n.cards.update(a.id,{status:t}),!0):!1},assignToClinic:async(e,t)=>{const r=await n.clinics.getAll(),a=await n.cards.getAll(),s=r.find(i=>i.id===t);if(!s)return!1;const d=a.filter(i=>i.clinicId===t).length,m=h[s.plan];return d+e.length>m?!1:(await Promise.all(e.map(async i=>{const u=a.find(c=>c.controlNumber===i);u&&await n.cards.update(u.id,{clinicId:t})})),!0)},updatePerks:async(e,t)=>{const a=(await n.cards.getAll()).find(s=>s.controlNumber===e);if(a){const s=Math.min(t,a.perksTotal);return await n.cards.update(a.id,{perksUsed:s}),!0}return!1},delete:async e=>{const r=(await n.cards.getAll()).find(a=>a.controlNumber===e);return r?(await n.cards.remove(r.id),!0):!1}},T={getAll:async()=>await n.perks.getAll(),getById:async e=>(await n.perks.getAll()).find(r=>r.id===e)||null,getByType:async e=>(await n.perks.getAll()).filter(r=>r.type===e),getActive:async()=>(await n.perks.getAll()).filter(t=>t.isActive),create:async e=>{const t={...e,id:`perk_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};return await n.perks.add(t),t},update:async(e,t)=>{if((await n.perks.getAll()).find(s=>s.id===e)){const s={...t,updatedAt:new Date().toISOString()};return await n.perks.update(e,s),!0}return!1},delete:async e=>(await n.perks.remove(e),!0),initializeDefaults:async()=>{(await n.perks.getAll()).length===0&&await Promise.all(b.map(async t=>{await T.create(t)}))}},_={getAll:async()=>{try{return await n.clinics.getAll()}catch(e){console.warn("Cloud sync failed, using Supabase fallback:",e);const{data:t}=await E.from("clinics").select("*");return(t||[]).map(r=>({id:r.id,name:r.clinic_name,username:r.clinic_code.toLowerCase(),region:"4A",plan:"starter",code:r.clinic_code,password:r.password_hash,subscriptionPrice:O.starter,subscriptionStatus:"active",subscriptionStartDate:new Date().toISOString(),maxCards:h.starter,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),isActive:!0}))}},getById:async e=>(await n.clinics.getAll()).find(r=>r.id===e)||null,getByCode:async e=>(await n.clinics.getAll()).find(r=>r.code===e)||null,authenticate:async(e,t)=>{try{const{data:r}=await E.from("clinics").select("*").eq("clinic_code",e).single();if(r&&r.password_hash===t)return{id:r.id,name:r.clinic_name,username:r.clinic_code.toLowerCase(),region:"4A",plan:"starter",code:r.clinic_code,password:r.password_hash,subscriptionPrice:O.starter,subscriptionStatus:"active",subscriptionStartDate:new Date().toISOString(),maxCards:h.starter,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),isActive:!0}}catch(r){console.error("Authentication error:",r)}return null},create:async e=>{const t={...e,id:`clinic_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,subscriptionStatus:"active",subscriptionStartDate:new Date().toISOString(),maxCards:h[e.plan],createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),isActive:!0};return await n.clinics.add(t),t},update:async(e,t)=>(await n.clinics.getAll()).find(s=>s.id===e)?(await n.clinics.update(e,t),!0):!1,delete:async e=>(await n.clinics.remove(e),!0),getAssignedCardsCount:async e=>(await n.cards.getAll()).filter(r=>r.clinicId===e).length,getPlanLimit:async e=>{const r=(await n.clinics.getAll()).find(a=>a.id===e);return r?h[r.plan]:0}},P={getAll:async()=>await n.appointments.getAll(),getByClinicId:async e=>(await n.appointments.getAll()).filter(r=>r.clinicId===e),create:async e=>{const t={...e,id:`appointment_${Date.now()}_${Math.random().toString(36).substr(2,9)}`};return await n.appointments.add(t),t},updateStatus:async(e,t)=>(await n.appointments.getAll()).find(s=>s.id===e)?(await n.appointments.update(e,{status:t}),!0):!1},$={getAll:async()=>await n.perkRedemptions.getAll(),getByCardNumber:async e=>(await n.perkRedemptions.getAll()).filter(r=>r.cardControlNumber===e),getByClinicId:async e=>(await n.perkRedemptions.getAll()).filter(r=>r.clinicId===e),create:async e=>await n.perkRedemptions.add(e),getByPerkType:async(e,t)=>(await n.perkRedemptions.getAll()).filter(a=>a.cardControlNumber===e&&a.perkName.toLowerCase().includes(t.toLowerCase()))};export{P as a,x as b,_ as c,T as d,$ as p,G as u};
