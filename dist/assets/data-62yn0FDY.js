import{r as w}from"./charts-sad3owxz.js";import{u as y,t as h,a as A,f as n,e as f,D as k}from"./index-C0m9om5s.js";const I=(t={})=>{const{enabled:e=!0,checkInterval:a=3e4,showNotifications:r=!0}=t,{addToast:s}=y(),o=w.useRef(null),d=w.useRef(!1),i=async()=>{try{{const u=await(await fetch("/index.html",{cache:"no-cache",headers:{"Cache-Control":"no-cache"}})).text(),p=u.match(/<script[^>]*src="[^"]*assets[^"]*\.js"[^>]*>/),g=u.match(/<meta name="version" content="([^"]*)">/);return g?g[1]:p?p[0]:null}}catch(l){return console.warn("Failed to check for app updates:",l),null}},c=async()=>{if(!(d.current||!e)){d.current=!0;try{const l=await i();if(l&&o.current){if(l!==o.current){r&&s(h("App Updated","A new version is available. The page will refresh automatically.")),setTimeout(()=>{window.location.reload()},2e3);return}}else l&&!o.current&&(o.current=l)}catch(l){console.warn("Update check failed:",l)}finally{d.current=!1}}};return w.useEffect(()=>{if(!e)return;i().then(g=>{o.current=g});const l=setInterval(c,a),u=()=>{document.hidden||setTimeout(c,1e3)};document.addEventListener("visibilitychange",u);const p=()=>{setTimeout(c,1e3)};return window.addEventListener("online",p),()=>{clearInterval(l),document.removeEventListener("visibilitychange",u),window.removeEventListener("online",p)}},[e,a,r]),{forceRefresh:()=>{r&&s(A("Refreshing","Updating to the latest version...")),setTimeout(()=>{window.location.reload()},500)},checkForUpdates:c}},C=(t,e,a)=>`MOC-${t.toString().padStart(5,"0")}-${e}-${a}`,T=async t=>{const a=(await n.clinics.getAll()).map(s=>s.code);let r=1;if(t==="Custom"||t==="Others"){for(;a.includes(`CVT${r.toString().padStart(3,"0")}`);)r++;return`CVT${r.toString().padStart(3,"0")}`}return t},B={getAll:async()=>await n.cards.getAll(),getByControlNumber:async t=>(await n.cards.getAll()).find(a=>a.controlNumber===t)||null,getByClinicId:async t=>(await n.cards.getAll()).filter(a=>a.clinicId===t),create:async t=>{try{return await n.cards.add(t)}catch(e){throw console.error("Failed to create card:",e),e}},createBatch:async(t,e,a,r,s=5)=>{const o=[];console.log("[BATCH] Creating batch cards from",t,"to",e);for(let d=t;d<=e;d++){const i={controlNumber:C(d,a,r),fullName:"",status:"inactive",perksTotal:s,perksUsed:0,clinicId:"",expiryDate:"2025-12-31"};console.log("[BATCH] Creating card:",i.controlNumber);try{const c=await n.cards.add(i);o.push(c),console.log("[BATCH] Card created successfully:",c.controlNumber)}catch(c){throw console.error("[BATCH] Failed to create card:",i.controlNumber,c),new Error(`Failed to create card ${i.controlNumber}: ${c instanceof Error?c.message:"Unknown error"}`)}}return console.log("[BATCH] Successfully created",o.length,"cards"),o},updateStatus:async(t,e)=>{const r=(await n.cards.getAll()).find(s=>s.controlNumber===t);return r?(await n.cards.update(r.id,{status:e}),!0):!1},assignToClinic:async(t,e)=>{const a=await n.clinics.getAll(),r=await n.cards.getAll(),s=a.find(i=>i.id===e);if(!s)return!1;const o=r.filter(i=>i.clinicId===e).length,d=f[s.plan];return o+t.length>d?!1:(await Promise.all(t.map(async i=>{const c=r.find(m=>m.controlNumber===i);c&&await n.cards.update(c.id,{clinicId:e})})),!0)},updatePerks:async(t,e)=>{const r=(await n.cards.getAll()).find(s=>s.controlNumber===t);if(r){const s=Math.min(e,r.perksTotal);return await n.cards.update(r.id,{perksUsed:s}),!0}return!1},delete:async t=>{const a=(await n.cards.getAll()).find(r=>r.controlNumber===t);return a?(await n.cards.remove(a.id),!0):!1}},S={getAll:async()=>await n.perks.getAll(),getById:async t=>(await n.perks.getAll()).find(a=>a.id===t)||null,getByType:async t=>(await n.perks.getAll()).filter(a=>a.type===t),getActive:async()=>(await n.perks.getAll()).filter(e=>e.isActive),create:async t=>{const e={...t,id:`perk_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};return await n.perks.add(e),e},update:async(t,e)=>{if((await n.perks.getAll()).find(s=>s.id===t)){const s={...e,updatedAt:new Date().toISOString()};return await n.perks.update(t,s),!0}return!1},delete:async t=>(await n.perks.remove(t),!0),initializeDefaults:async()=>{(await n.perks.getAll()).length===0&&await Promise.all(k.map(async e=>{await S.create(e)}))}},N={getAll:async()=>await n.clinics.getAll(),getById:async t=>(await n.clinics.getAll()).find(a=>a.id===t)||null,getByCode:async t=>(await n.clinics.getAll()).find(a=>a.code===t)||null,authenticate:async(t,e)=>(await n.clinics.getAll()).find(r=>r.username===t&&r.password===e)||null,create:async t=>{const e={...t,id:`clinic_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,subscriptionStatus:"active",subscriptionStartDate:new Date().toISOString(),maxCards:f[t.plan],createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),isActive:!0};return await n.clinics.add(e),e},update:async(t,e)=>(await n.clinics.getAll()).find(s=>s.id===t)?(await n.clinics.update(t,e),!0):!1,delete:async t=>(await n.clinics.remove(t),!0),getAssignedCardsCount:async t=>(await n.cards.getAll()).filter(a=>a.clinicId===t).length,getPlanLimit:async t=>{const a=(await n.clinics.getAll()).find(r=>r.id===t);return a?f[a.plan]:0}},O={getAll:async()=>await n.appointments.getAll(),getByClinicId:async t=>(await n.appointments.getAll()).filter(a=>a.clinicId===t),create:async t=>{const e={...t,id:`appointment_${Date.now()}_${Math.random().toString(36).substr(2,9)}`};return await n.appointments.add(e),e},updateStatus:async(t,e)=>(await n.appointments.getAll()).find(s=>s.id===t)?(await n.appointments.update(t,{status:e}),!0):!1},D={getAll:async()=>await n.perkRedemptions.getAll(),getByCardNumber:async t=>(await n.perkRedemptions.getAll()).filter(a=>a.cardControlNumber===t),getByClinicId:async t=>(await n.perkRedemptions.getAll()).filter(a=>a.clinicId===t),create:async t=>await n.perkRedemptions.add(t),getByPerkType:async(t,e)=>(await n.perkRedemptions.getAll()).filter(r=>r.cardControlNumber===t&&r.perkName.toLowerCase().includes(e.toLowerCase()))};export{O as a,B as b,N as c,S as d,T as e,C as g,D as p,I as u};
