import{r as R}from"./charts-sad3owxz.js";import{u as k,t as N,a as O,f as r,e as y,D as C}from"./index-CYnEd8Ml.js";const v=(e={})=>{const{enabled:t=!0,checkInterval:n=3e4,showNotifications:a=!0}=e,{addToast:s}=k(),d=R.useRef(null),f=R.useRef(!1),i=async()=>{try{{const l=await(await fetch("/index.html",{cache:"no-cache",headers:{"Cache-Control":"no-cache"}})).text(),m=l.match(/<script[^>]*src="[^"]*assets[^"]*\.js"[^>]*>/),g=l.match(/<meta name="version" content="([^"]*)">/);return g?g[1]:m?m[0]:null}}catch(o){return console.warn("Failed to check for app updates:",o),null}},u=async()=>{if(!(f.current||!t)){f.current=!0;try{const o=await i();if(o&&d.current){if(o!==d.current){a&&s(N("App Updated","A new version is available. The page will refresh automatically.")),setTimeout(()=>{window.location.reload()},2e3);return}}else o&&!d.current&&(d.current=o)}catch(o){console.warn("Update check failed:",o)}finally{f.current=!1}}};return R.useEffect(()=>{if(!t)return;i().then(g=>{d.current=g});const o=setInterval(u,n),l=()=>{document.hidden||setTimeout(u,1e3)};document.addEventListener("visibilitychange",l);const m=()=>{setTimeout(u,1e3)};return window.addEventListener("online",m),()=>{clearInterval(o),document.removeEventListener("visibilitychange",l),window.removeEventListener("online",m)}},[t,n,a]),{forceRefresh:()=>{a&&s(O("Refreshing","Updating to the latest version...")),setTimeout(()=>{window.location.reload()},500)},checkForUpdates:u}},T=(e,t,n)=>`MOC-${e.toString().padStart(5,"0")}-${t}-${n}`,G=async e=>{const n=(await r.clinics.getAll()).map(s=>s.code);let a=1;if(e==="Custom"||e==="Others"){for(;n.includes(`CVT${a.toString().padStart(3,"0")}`);)a++;return`CVT${a.toString().padStart(3,"0")}`}return e},x={getAll:async()=>await r.cards.getAll(),getByControlNumber:async e=>(await r.cards.getAll()).find(n=>n.controlNumber===e)||null,getByClinicId:async e=>(await r.cards.getAll()).filter(n=>n.clinicId===e),create:async e=>{try{return await r.cards.add(e)}catch(t){throw console.error("Failed to create card:",t),t}},generateCards:async(e,t,n,a=5)=>{const s=[];if(console.log("[GENERATOR] Creating",e,"cards with region:",t,"areaCode:",n),!t||!n)throw console.error("[GENERATOR] Invalid input - region and areaCode are required"),console.error("[GENERATOR] Received:",{region:t,areaCode:n,quantity:e,perksTotal:a}),new Error("Region and Area Code are required for card generation");if(e<=0)throw console.error("[GENERATOR] Invalid quantity:",e),new Error("Quantity must be greater than 0");console.log("[GENERATOR] Input validation passed"),console.log("[GENERATOR] Fetching existing cards...");const d=await r.cards.getAll();console.log("[GENERATOR] Found",d.length,"existing cards");const f=new Set(d.map(p=>p.controlNumber));let i=1;console.log("[GENERATOR] Finding highest existing ID across all cards...");const u=d.filter(p=>p.controlNumber.startsWith("MOC-"));if(console.log("[GENERATOR] Found",u.length,"existing MOC cards"),u.length>0){const p=Math.max(...u.map(h=>{const w=h.controlNumber.match(/MOC-(\d+)/);return w?parseInt(w[1]):0}));i=p+1,console.log("[GENERATOR] Highest existing ID found:",p,"- Starting from:",i)}else console.log("[GENERATOR] No existing MOC cards found, starting from ID 1");console.log("[GENERATOR] Starting from ID:",i);let c=0,o=0,l=0;const m=e*5,g=Math.min(10,Math.max(5,e/10)),A=50;for(console.log("[GENERATOR] Configuration:",{maxAttempts:m,maxConsecutiveFailures:g,batchSize:A,targetQuantity:e}),console.log("[GENERATOR] Processing in batches for optimal performance...");c<e&&o<m&&l<g;){const p=T(i,t,n);if(o++,f.has(p)){console.log("[GENERATOR] Skipping existing card:",p),i++;continue}const h={controlNumber:p,fullName:"",status:"inactive",perksTotal:a,perksUsed:0,clinicId:"",expiryDate:"2025-12-31"};try{const w=await r.cards.add(h);s.push(w),f.add(p),c++,i++,l=0,(c%10===0||c===1||c===e)&&console.log(`[GENERATOR] Progress: ${c}/${e} cards created (${Math.round(c/e*100)}%)`),c%A===0&&c<e&&(console.log(`[GENERATOR] Batch of ${A} completed, brief pause...`),await new Promise(E=>setTimeout(E,100)))}catch(w){if(console.error("[GENERATOR] Failed to create card:",h.controlNumber,w),l++,i++,l>=g){console.error(`[GENERATOR] Too many consecutive failures (${l}), stopping generation.`);break}else console.log(`[GENERATOR] Continuing after failure (${l}/${g})...`)}}return c<e&&console.warn(`[GENERATOR] Only created ${c} out of ${e} requested cards`),console.log("[GENERATOR] Successfully created",c,"unique cards"),s},updateStatus:async(e,t)=>{const a=(await r.cards.getAll()).find(s=>s.controlNumber===e);return a?(await r.cards.update(a.id,{status:t}),!0):!1},assignToClinic:async(e,t)=>{const n=await r.clinics.getAll(),a=await r.cards.getAll(),s=n.find(i=>i.id===t);if(!s)return!1;const d=a.filter(i=>i.clinicId===t).length,f=y[s.plan];return d+e.length>f?!1:(await Promise.all(e.map(async i=>{const u=a.find(c=>c.controlNumber===i);u&&await r.cards.update(u.id,{clinicId:t})})),!0)},updatePerks:async(e,t)=>{const a=(await r.cards.getAll()).find(s=>s.controlNumber===e);if(a){const s=Math.min(t,a.perksTotal);return await r.cards.update(a.id,{perksUsed:s}),!0}return!1},delete:async e=>{const n=(await r.cards.getAll()).find(a=>a.controlNumber===e);return n?(await r.cards.remove(n.id),!0):!1}},S={getAll:async()=>await r.perks.getAll(),getById:async e=>(await r.perks.getAll()).find(n=>n.id===e)||null,getByType:async e=>(await r.perks.getAll()).filter(n=>n.type===e),getActive:async()=>(await r.perks.getAll()).filter(t=>t.isActive),create:async e=>{const t={...e,id:`perk_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};return await r.perks.add(t),t},update:async(e,t)=>{if((await r.perks.getAll()).find(s=>s.id===e)){const s={...t,updatedAt:new Date().toISOString()};return await r.perks.update(e,s),!0}return!1},delete:async e=>(await r.perks.remove(e),!0),initializeDefaults:async()=>{(await r.perks.getAll()).length===0&&await Promise.all(C.map(async t=>{await S.create(t)}))}},$={getAll:async()=>await r.clinics.getAll(),getById:async e=>(await r.clinics.getAll()).find(n=>n.id===e)||null,getByCode:async e=>(await r.clinics.getAll()).find(n=>n.code===e)||null,authenticate:async(e,t)=>(await r.clinics.getAll()).find(a=>a.username===e&&a.password===t)||null,create:async e=>{const t={...e,id:`clinic_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,subscriptionStatus:"active",subscriptionStartDate:new Date().toISOString(),maxCards:y[e.plan],createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),isActive:!0};return await r.clinics.add(t),t},update:async(e,t)=>(await r.clinics.getAll()).find(s=>s.id===e)?(await r.clinics.update(e,t),!0):!1,delete:async e=>(await r.clinics.remove(e),!0),getAssignedCardsCount:async e=>(await r.cards.getAll()).filter(n=>n.clinicId===e).length,getPlanLimit:async e=>{const n=(await r.clinics.getAll()).find(a=>a.id===e);return n?y[n.plan]:0}},D={getAll:async()=>await r.appointments.getAll(),getByClinicId:async e=>(await r.appointments.getAll()).filter(n=>n.clinicId===e),create:async e=>{const t={...e,id:`appointment_${Date.now()}_${Math.random().toString(36).substr(2,9)}`};return await r.appointments.add(t),t},updateStatus:async(e,t)=>(await r.appointments.getAll()).find(s=>s.id===e)?(await r.appointments.update(e,{status:t}),!0):!1},M={getAll:async()=>await r.perkRedemptions.getAll(),getByCardNumber:async e=>(await r.perkRedemptions.getAll()).filter(n=>n.cardControlNumber===e),getByClinicId:async e=>(await r.perkRedemptions.getAll()).filter(n=>n.clinicId===e),create:async e=>await r.perkRedemptions.add(e),getByPerkType:async(e,t)=>(await r.perkRedemptions.getAll()).filter(a=>a.cardControlNumber===e&&a.perkName.toLowerCase().includes(t.toLowerCase()))};export{D as a,x as b,$ as c,S as d,G as g,M as p,v as u};
