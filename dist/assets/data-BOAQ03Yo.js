import{r as f}from"./charts-sad3owxz.js";import{u as A,t as h,a as k,f as a,e as y,D as C}from"./index-DfrNaHlf.js";const E=(t={})=>{const{enabled:e=!0,checkInterval:n=3e4,showNotifications:r=!0}=t,{addToast:s}=A(),d=f.useRef(null),m=f.useRef(!1),c=async()=>{try{{const w=await(await fetch("/index.html",{cache:"no-cache",headers:{"Cache-Control":"no-cache"}})).text(),o=w.match(/<script[^>]*src="[^"]*assets[^"]*\.js"[^>]*>/),l=w.match(/<meta name="version" content="([^"]*)">/);return l?l[1]:o?o[0]:null}}catch(i){return console.warn("Failed to check for app updates:",i),null}},u=async()=>{if(!(m.current||!e)){m.current=!0;try{const i=await c();if(i&&d.current){if(i!==d.current){r&&s(h("App Updated","A new version is available. The page will refresh automatically.")),setTimeout(()=>{window.location.reload()},2e3);return}}else i&&!d.current&&(d.current=i)}catch(i){console.warn("Update check failed:",i)}finally{m.current=!1}}};return f.useEffect(()=>{if(!e)return;c().then(l=>{d.current=l});const i=setInterval(u,n),w=()=>{document.hidden||setTimeout(u,1e3)};document.addEventListener("visibilitychange",w);const o=()=>{setTimeout(u,1e3)};return window.addEventListener("online",o),()=>{clearInterval(i),document.removeEventListener("visibilitychange",w),window.removeEventListener("online",o)}},[e,n,r]),{forceRefresh:()=>{r&&s(k("Refreshing","Updating to the latest version...")),setTimeout(()=>{window.location.reload()},500)},checkForUpdates:u}},S=(t,e,n)=>`MOC-${t.toString().padStart(5,"0")}-${e}-${n}`,I=async t=>{const n=(await a.clinics.getAll()).map(s=>s.code);let r=1;if(t==="Custom"||t==="Others"){for(;n.includes(`CVT${r.toString().padStart(3,"0")}`);)r++;return`CVT${r.toString().padStart(3,"0")}`}return t},O={getAll:async()=>await a.cards.getAll(),getByControlNumber:async t=>(await a.cards.getAll()).find(n=>n.controlNumber===t)||null,getByClinicId:async t=>(await a.cards.getAll()).filter(n=>n.clinicId===t),create:async t=>{try{return await a.cards.add(t)}catch(e){throw console.error("Failed to create card:",e),e}},generateCards:async(t,e,n,r=5)=>{const s=[];console.log("[GENERATOR] Creating",t,"cards with region:",e,"areaCode:",n);const d=await a.cards.getAll(),m=new Set(d.map(o=>o.controlNumber));let c=1;const u=new RegExp(`MOC-(\\d+)-${e}-${n}`);d.forEach(o=>{const l=o.controlNumber.match(u);if(l){const g=parseInt(l[1]);g>=c&&(c=g+1)}}),console.log("[GENERATOR] Starting from ID:",c);let p=0,i=0;const w=t*2;for(;p<t&&i<w;){const o=S(c,e,n);if(i++,m.has(o)){console.log("[GENERATOR] Skipping existing card:",o),c++;continue}const l={controlNumber:o,fullName:"",status:"inactive",perksTotal:r,perksUsed:0,clinicId:"",expiryDate:"2025-12-31"};console.log("[GENERATOR] Creating card:",l.controlNumber);try{const g=await a.cards.add(l);s.push(g),m.add(o),p++,c++,console.log(`[GENERATOR] Card created successfully (${p}/${t}):`,g.controlNumber)}catch(g){throw console.error("[GENERATOR] Failed to create card:",l.controlNumber,g),new Error(`Failed to create card ${l.controlNumber}: ${g instanceof Error?g.message:"Unknown error"}`)}}return p<t&&console.warn(`[GENERATOR] Only created ${p} out of ${t} requested cards`),console.log("[GENERATOR] Successfully created",p,"unique cards"),s},updateStatus:async(t,e)=>{const r=(await a.cards.getAll()).find(s=>s.controlNumber===t);return r?(await a.cards.update(r.id,{status:e}),!0):!1},assignToClinic:async(t,e)=>{const n=await a.clinics.getAll(),r=await a.cards.getAll(),s=n.find(c=>c.id===e);if(!s)return!1;const d=r.filter(c=>c.clinicId===e).length,m=y[s.plan];return d+t.length>m?!1:(await Promise.all(t.map(async c=>{const u=r.find(p=>p.controlNumber===c);u&&await a.cards.update(u.id,{clinicId:e})})),!0)},updatePerks:async(t,e)=>{const r=(await a.cards.getAll()).find(s=>s.controlNumber===t);if(r){const s=Math.min(e,r.perksTotal);return await a.cards.update(r.id,{perksUsed:s}),!0}return!1},delete:async t=>{const n=(await a.cards.getAll()).find(r=>r.controlNumber===t);return n?(await a.cards.remove(n.id),!0):!1}},R={getAll:async()=>await a.perks.getAll(),getById:async t=>(await a.perks.getAll()).find(n=>n.id===t)||null,getByType:async t=>(await a.perks.getAll()).filter(n=>n.type===t),getActive:async()=>(await a.perks.getAll()).filter(e=>e.isActive),create:async t=>{const e={...t,id:`perk_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};return await a.perks.add(e),e},update:async(t,e)=>{if((await a.perks.getAll()).find(s=>s.id===t)){const s={...e,updatedAt:new Date().toISOString()};return await a.perks.update(t,s),!0}return!1},delete:async t=>(await a.perks.remove(t),!0),initializeDefaults:async()=>{(await a.perks.getAll()).length===0&&await Promise.all(C.map(async e=>{await R.create(e)}))}},v={getAll:async()=>await a.clinics.getAll(),getById:async t=>(await a.clinics.getAll()).find(n=>n.id===t)||null,getByCode:async t=>(await a.clinics.getAll()).find(n=>n.code===t)||null,authenticate:async(t,e)=>(await a.clinics.getAll()).find(r=>r.username===t&&r.password===e)||null,create:async t=>{const e={...t,id:`clinic_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,subscriptionStatus:"active",subscriptionStartDate:new Date().toISOString(),maxCards:y[t.plan],createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),isActive:!0};return await a.clinics.add(e),e},update:async(t,e)=>(await a.clinics.getAll()).find(s=>s.id===t)?(await a.clinics.update(t,e),!0):!1,delete:async t=>(await a.clinics.remove(t),!0),getAssignedCardsCount:async t=>(await a.cards.getAll()).filter(n=>n.clinicId===t).length,getPlanLimit:async t=>{const n=(await a.clinics.getAll()).find(r=>r.id===t);return n?y[n.plan]:0}},T={getAll:async()=>await a.appointments.getAll(),getByClinicId:async t=>(await a.appointments.getAll()).filter(n=>n.clinicId===t),create:async t=>{const e={...t,id:`appointment_${Date.now()}_${Math.random().toString(36).substr(2,9)}`};return await a.appointments.add(e),e},updateStatus:async(t,e)=>(await a.appointments.getAll()).find(s=>s.id===t)?(await a.appointments.update(t,{status:e}),!0):!1},$={getAll:async()=>await a.perkRedemptions.getAll(),getByCardNumber:async t=>(await a.perkRedemptions.getAll()).filter(n=>n.cardControlNumber===t),getByClinicId:async t=>(await a.perkRedemptions.getAll()).filter(n=>n.clinicId===t),create:async t=>await a.perkRedemptions.add(t),getByPerkType:async(t,e)=>(await a.perkRedemptions.getAll()).filter(r=>r.cardControlNumber===t&&r.perkName.toLowerCase().includes(e.toLowerCase()))};export{T as a,O as b,v as c,R as d,I as g,$ as p,E as u};
