import{r as y}from"./charts-sad3owxz.js";import{u as O,t as k,a as N,f as r,e as h,s as E,d as S,D as b}from"./index-n6d5soqr.js";const x=(e={})=>{const{enabled:n=!0,checkInterval:t=3e4,showNotifications:a=!0}=e,{addToast:s}=O(),d=y.useRef(null),m=y.useRef(!1),i=async()=>{try{{const l=await(await fetch("/index.html",{cache:"no-cache",headers:{"Cache-Control":"no-cache"}})).text(),w=l.match(/<script[^>]*src="[^"]*assets[^"]*\.js"[^>]*>/),g=l.match(/<meta name="version" content="([^"]*)">/);return g?g[1]:w?w[0]:null}}catch(o){return console.warn("Failed to check for app updates:",o),null}},u=async()=>{if(!(m.current||!n)){m.current=!0;try{const o=await i();if(o&&d.current){if(o!==d.current){a&&s(k("App Updated","A new version is available. The page will refresh automatically.")),setTimeout(()=>{window.location.reload()},2e3);return}}else o&&!d.current&&(d.current=o)}catch(o){console.warn("Update check failed:",o)}finally{m.current=!1}}};return y.useEffect(()=>{if(!n)return;i().then(g=>{d.current=g});const o=setInterval(u,t),l=()=>{document.hidden||setTimeout(u,1e3)};document.addEventListener("visibilitychange",l);const w=()=>{setTimeout(u,1e3)};return window.addEventListener("online",w),()=>{clearInterval(o),document.removeEventListener("visibilitychange",l),window.removeEventListener("online",w)}},[n,t,a]),{forceRefresh:()=>{a&&s(N("Refreshing","Updating to the latest version...")),setTimeout(()=>{window.location.reload()},500)},checkForUpdates:u}},I=(e,n,t)=>`MOC-${e.toString().padStart(5,"0")}-${n}-${t}`,G=async e=>{const t=(await r.clinics.getAll()).map(s=>s.code);let a=1;if(e==="Custom"||e==="Others"){for(;t.includes(`CVT${a.toString().padStart(3,"0")}`);)a++;return`CVT${a.toString().padStart(3,"0")}`}return e},$={getAll:async()=>await r.cards.getAll(),getByControlNumber:async e=>(await r.cards.getAll()).find(t=>t.controlNumber===e)||null,getByClinicId:async e=>(await r.cards.getAll()).filter(t=>t.clinicId===e),create:async e=>{try{return await r.cards.add(e)}catch(n){throw console.error("Failed to create card:",n),n}},generateCards:async(e,n,t,a=5)=>{const s=[];if(console.log("[GENERATOR] Creating",e,"cards with region:",n,"areaCode:",t),!n||!t)throw console.error("[GENERATOR] Invalid input - region and areaCode are required"),console.error("[GENERATOR] Received:",{region:n,areaCode:t,quantity:e,perksTotal:a}),new Error("Region and Area Code are required for card generation");if(e<=0)throw console.error("[GENERATOR] Invalid quantity:",e),new Error("Quantity must be greater than 0");console.log("[GENERATOR] Input validation passed"),console.log("[GENERATOR] Fetching existing cards...");const d=await r.cards.getAll();console.log("[GENERATOR] Found",d.length,"existing cards");const m=new Set(d.map(p=>p.controlNumber));let i=1;console.log("[GENERATOR] Finding highest existing ID across all cards...");const u=d.filter(p=>p.controlNumber.startsWith("MOC-"));if(console.log("[GENERATOR] Found",u.length,"existing MOC cards"),u.length>0){const p=Math.max(...u.map(A=>{const f=A.controlNumber.match(/MOC-(\d+)/);return f?parseInt(f[1]):0}));i=p+1,console.log("[GENERATOR] Highest existing ID found:",p,"- Starting from:",i)}else console.log("[GENERATOR] No existing MOC cards found, starting from ID 1");console.log("[GENERATOR] Starting from ID:",i);let c=0,o=0,l=0;const w=e*5,g=Math.min(10,Math.max(5,e/10)),R=50;for(console.log("[GENERATOR] Configuration:",{maxAttempts:w,maxConsecutiveFailures:g,batchSize:R,targetQuantity:e}),console.log("[GENERATOR] Processing in batches for optimal performance...");c<e&&o<w&&l<g;){const p=I(i,n,t);if(o++,m.has(p)){console.log("[GENERATOR] Skipping existing card:",p),i++;continue}const A={controlNumber:p,fullName:"",status:"inactive",perksTotal:a,perksUsed:0,clinicId:"",expiryDate:"2025-12-31"};try{const f=await r.cards.add(A);s.push(f),m.add(p),c++,i++,l=0,(c%10===0||c===1||c===e)&&console.log(`[GENERATOR] Progress: ${c}/${e} cards created (${Math.round(c/e*100)}%)`),c%R===0&&c<e&&(console.log(`[GENERATOR] Batch of ${R} completed, brief pause...`),await new Promise(C=>setTimeout(C,100)))}catch(f){if(console.error("[GENERATOR] Failed to create card:",A.controlNumber,f),l++,i++,l>=g){console.error(`[GENERATOR] Too many consecutive failures (${l}), stopping generation.`);break}else console.log(`[GENERATOR] Continuing after failure (${l}/${g})...`)}}return c<e&&console.warn(`[GENERATOR] Only created ${c} out of ${e} requested cards`),console.log("[GENERATOR] Successfully created",c,"unique cards"),s},updateStatus:async(e,n)=>{const a=(await r.cards.getAll()).find(s=>s.controlNumber===e);return a?(await r.cards.update(a.id,{status:n}),!0):!1},assignToClinic:async(e,n)=>{const t=await r.clinics.getAll(),a=await r.cards.getAll(),s=t.find(i=>i.id===n);if(!s)return!1;const d=a.filter(i=>i.clinicId===n).length,m=h[s.plan];return d+e.length>m?!1:(await Promise.all(e.map(async i=>{const u=a.find(c=>c.controlNumber===i);u&&await r.cards.update(u.id,{clinicId:n})})),!0)},updatePerks:async(e,n)=>{const a=(await r.cards.getAll()).find(s=>s.controlNumber===e);if(a){const s=Math.min(n,a.perksTotal);return await r.cards.update(a.id,{perksUsed:s}),!0}return!1},delete:async e=>{const t=(await r.cards.getAll()).find(a=>a.controlNumber===e);return t?(await r.cards.remove(t.id),!0):!1}},T={getAll:async()=>await r.perks.getAll(),getById:async e=>(await r.perks.getAll()).find(t=>t.id===e)||null,getByType:async e=>(await r.perks.getAll()).filter(t=>t.type===e),getActive:async()=>(await r.perks.getAll()).filter(n=>n.isActive),create:async e=>{const n={...e,id:`perk_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};return await r.perks.add(n),n},update:async(e,n)=>{if((await r.perks.getAll()).find(s=>s.id===e)){const s={...n,updatedAt:new Date().toISOString()};return await r.perks.update(e,s),!0}return!1},delete:async e=>(await r.perks.remove(e),!0),initializeDefaults:async()=>{(await r.perks.getAll()).length===0&&await Promise.all(b.map(async n=>{await T.create(n)}))}},_={getAll:async()=>{try{return await r.clinics.getAll()}catch(e){console.warn("Cloud sync failed, using Supabase fallback:",e);const{data:n}=await E.from("clinics").select("*");return(n||[]).map(t=>({id:t.id,name:t.clinic_name,username:t.clinic_code.toLowerCase(),region:"4A",plan:"starter",code:t.clinic_code,password:t.password_hash,subscriptionPrice:S.starter,subscriptionStatus:"active",subscriptionStartDate:new Date().toISOString(),maxCards:h.starter,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),isActive:!0}))}},getById:async e=>(await r.clinics.getAll()).find(t=>t.id===e)||null,getByCode:async e=>(await r.clinics.getAll()).find(t=>t.code===e)||null,authenticate:async(e,n)=>{try{const{data:t}=await E.from("clinics").select("*").eq("clinic_code",e).single();if(t&&t.password_hash===n)return{id:t.id,name:t.clinic_name,username:t.clinic_code.toLowerCase(),region:"4A",plan:"starter",code:t.clinic_code,password:t.password_hash,subscriptionPrice:S.starter,subscriptionStatus:"active",subscriptionStartDate:new Date().toISOString(),maxCards:h.starter,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),isActive:!0}}catch(t){console.error("Authentication error:",t)}return null},create:async e=>{const n={...e,id:`clinic_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,subscriptionStatus:"active",subscriptionStartDate:new Date().toISOString(),maxCards:h[e.plan],createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),isActive:!0};return await r.clinics.add(n),n},update:async(e,n)=>(await r.clinics.getAll()).find(s=>s.id===e)?(await r.clinics.update(e,n),!0):!1,delete:async e=>(await r.clinics.remove(e),!0),getAssignedCardsCount:async e=>(await r.cards.getAll()).filter(t=>t.clinicId===e).length,getPlanLimit:async e=>{const t=(await r.clinics.getAll()).find(a=>a.id===e);return t?h[t.plan]:0}},M={getAll:async()=>await r.appointments.getAll(),getByClinicId:async e=>(await r.appointments.getAll()).filter(t=>t.clinicId===e),create:async e=>{const n={...e,id:`appointment_${Date.now()}_${Math.random().toString(36).substr(2,9)}`};return await r.appointments.add(n),n},updateStatus:async(e,n)=>(await r.appointments.getAll()).find(s=>s.id===e)?(await r.appointments.update(e,{status:n}),!0):!1},P={getAll:async()=>await r.perkRedemptions.getAll(),getByCardNumber:async e=>(await r.perkRedemptions.getAll()).filter(t=>t.cardControlNumber===e),getByClinicId:async e=>(await r.perkRedemptions.getAll()).filter(t=>t.clinicId===e),create:async e=>await r.perkRedemptions.add(e),getByPerkType:async(e,n)=>(await r.perkRedemptions.getAll()).filter(a=>a.cardControlNumber===e&&a.perkName.toLowerCase().includes(n.toLowerCase()))};export{M as a,$ as b,_ as c,T as d,G as g,P as p,x as u};
